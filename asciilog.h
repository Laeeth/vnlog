#pragma once

#include <stdio.h>
#include <stdbool.h>

#ifdef ASCIILOG_N_FIELDS

  // We know how many fields we have. This is #included from a header generated by
  // asciilog-gen-header
  #define asciilog_emit_record_ctx(ctx)     _asciilog_emit_record   (ctx,      ASCIILOG_N_FIELDS)
  #define asciilog_emit_record()            _asciilog_emit_record   (NULL,     ASCIILOG_N_FIELDS)
  #define asciilog_init_session_ctx(ctx)    _asciilog_init_ctx      (ctx,      ASCIILOG_N_FIELDS)
  #define asciilog_init_child_ctx(dst, src) _asciilog_init_child_ctx(dst, src, ASCIILOG_N_FIELDS)
  #define asciilog_printf(...)              _asciilog_printf        (NULL, ## __VA_ARGS__)
  #define asciilog_printf_ctx(ctx, ...)     _asciilog_printf        (ctx, ## __VA_ARGS__)
  #define asciilog_flush()                  _asciilog_flush         (NULL)
  #define asciilog_flush_ctx(ctx)           _asciilog_flush         (ctx)

#else

  // We don't know how many fields we have. This is #included from asciilog.c

  #ifndef ASCIILOG_C
  #error Please do not include asciilog.h directly. Instead include the header made by asciilog-gen-header
  #endif

#endif


/*
This is an interface to produce asciilog output from C programs. Common usage:

  In a shell:

    asciilog-gen-header 'int w' 'uint8_t x' 'char* y' 'double z' > asciilog_fields_generated.h

  In a C program test.c:

    #include "asciilog_fields_generated.h"

    int main()
    {
        asciilog_emit_legend();

        asciilog_set_field_value__w(-10);
        asciilog_set_field_value__x(40);
        asciilog_set_field_value__y("asdf");
        asciilog_emit_record();

        asciilog_set_field_value__z(0.3);
        asciilog_set_field_value__x(50);
        asciilog_set_field_value__w(-20);
        asciilog_emit_record();

        return 0;
    }

  $ cc -o test test.c -lasciilog

  $ ./test

  # w x y z
  -10 40 asdf -
  -20 50 - 0.300000


Note that THIS FILE IS NOT MEANT TO BE #include-ed BY THE USER. IT SHOULD BE
INCLUDED BY THE GENERATED asciilog_fieldss_generated.h
 */


#define ASCIILOG_MAX_FIELD_LEN 32

typedef struct { char c[ASCIILOG_MAX_FIELD_LEN]; } asciilog_field_t;

// If we're building the LIBRARY, we don't know how many fields we'll have. The
// library never assumes it knows this: it never takes sizeof(struct
// asciilog_context_t, instantiates a new context and so on)
//
// Brand-new contexts are filled with 0, so make sure that all elements should
// start out at 0
struct asciilog_context_t
{
    // global state for this whole session. These are passed-down from parent
    // contexts by asciilog_init_child_ctx(). If we have a single asciilog
    // session in an executable, all the contexts have the same values for these
    FILE*            fp;
    bool             emitted_something   : 1;
    bool             legend_finished     : 1;

    // Each context manages its own set of fields. These could be different in
    // each context instance
    bool             line_has_any_values : 1;
    asciilog_field_t fields[
#ifdef ASCIILOG_N_FIELDS
                            ASCIILOG_N_FIELDS
#endif
                            ];
};



#ifdef __cplusplus
extern "C" {
#endif

// Directs the output to a given buffer. If this function is never called, the
// output goes to STDOUT. If it IS called, that must happen before anything else
void asciilog_set_output_FILE(struct asciilog_context_t* ctx,
                              FILE* _fp);

// THIS FUNCTION IS NOT A PART OF THE PUBLIC API. The user should call
//
//     asciilog_emit_legend()
//
// The header generated by asciilog-gen-header converts one call to the other.
// This is called once to write out the legend. Must be called before any data
// can be written
void _asciilog_emit_legend(struct asciilog_context_t* ctx,
                           const char* legend, int Nfields);

// THIS FUNCTION IS NOT A PART OF THE PUBLIC API. Instead the user should call
// either of
//
//     asciilog_set_field_value__FIELDNAME(value)
//     asciilog_set_field_value_ctx__FIELDNAME(ctx, value)
//
// depending on whether they want to use the default context or not. The header
// generated by asciilog-gen-header converts one call to the other.
void _asciilog_set_field_value(struct asciilog_context_t* ctx,
                               const char* fieldname, int idx,
                               const char* fmt, ...);

// THIS FUNCTION IS NOT A PART OF THE PUBLIC API. Instead, the user should call
// either of
//
//     asciilog_emit_record()
//     asciilog_emit_record_ctx(ctx)
//
// depending on whether they want to use the default context or not. Once all
// the fields for a record have been set with
// asciilog_set_field_value__FIELDNAME(), this function is called to emit the
// record. Any fields not set get written as -.
//
// This function is thread-safe, and multiple context can be safely written out
// from multiple threads
void _asciilog_emit_record(struct asciilog_context_t* ctx,
                           int Nfields);

// THIS FUNCTION IS NOT A PART OF THE PUBLIC API. Instead, the user should call
// either of
//
//     asciilog_emit_printf()
//     asciilog_emit_printf_ctx(ctx)
//
// depending on whether they want to use the default context or not. Writes out
// the given printf-style format to the asciilog. Generally this is a comment
// string, so it should start with a '#' and end in a '\n', but I do not check
// or enforce this.
void _asciilog_printf(struct asciilog_context_t* ctx,
                      const char* fmt, ...);

// THIS FUNCTION IS NOT A PART OF THE PUBLIC API. Instead, the user should call
// either of
//
//     asciilog_emit_printf()
//     asciilog_emit_printf_ctx(ctx)
//
// depending on whether they want to use the default context or not. Flushes the
// output buffer. Useful in conjunction with asciilog_printf()
void _asciilog_flush(struct asciilog_context_t* ctx);

// THIS FUNCTION IS NOT A PART OF THE PUBLIC API. Instead, the user should call
//
//     asciilog_init_child_ctx(ctx_dst, ctx_src)
//
// This function is used for sub-tables in an asciilog. I.e. we can accumulate
// multiple records at the same time. All the fields in any record are written
// all at once when asciilog_emit_record_ctx() is called for the context of each
// record. This is used for different records in the SAME asciilog. If you want
// a completely different asciilog, see asciilog_init_session_ctx(). The idiom
// is:
//
//     void f(void)
//     {
//         asciilog_emit_legend();
//
//         asciilog_set_field_value__x(...);
//         // we just set some fields in this record, and in the middle of filling
//         // this record we write other records
//         {
//             struct asciilog_context_t ctx;
//             asciilog_init_child_ctx(&ctx, NULL); // child of the global context
//             for(...)
//             {
//                 asciilog_set_field_value_ctx__y(&ctx, ...);
//                 ...
//                 asciilog_emit_record_ctx(&ctx);
//             }
//         }
//
//         // Now we resume the previous record. We still remember the value of x
//         asciilog_set_field_value__z(...);
//         asciilog_emit_record();
//     }
//
// ctx_from is the context from which we pull information global to this
// asciilog session. This is things like the FILE we're writing data to. If
// NULL, we use the global context.
void _asciilog_init_child_ctx( struct asciilog_context_t* ctx,
                               const struct asciilog_context_t* ctx_src,
                               int Nfields);

// THIS FUNCTION IS NOT A PART OF THE PUBLIC API. Instead, the user should call
//
//     asciilog_init_session_ctx(ctx)
//
// This function is used to initialize a new context to start a new asciilog
// session. MOST USES OF ASCIILOG DO NOT NEED TO USE THIS FUNCTION. Different
// sessions represent completely different asciilog data files. These can have
// different legends, and should send their output to different places using
// asciilog_set_output_FILE(). Since the legends are defined at compile-time,
// the code using each session MUST live in separate source files.
//
// The idiom is:
//
//   file1.c:
//
//     #include "asciilog_fields_generated1.h"
//     void f(void)
//     {
//         // Write some data out to the default context and default output (STDOUT)
//         asciilog_emit_legend();
//         ...
//         asciilog_set_field_value__w(...);
//         asciilog_set_field_value__x(...);
//         ...
//         asciilog_emit_record();
//     }
//
//   file2.c:
//
//     #include "asciilog_fields_generated2.h"
//     void g(void)
//     {
//         // Make a new session context, send output to a different file, write
//         // out legend, and send out the data
//         struct asciilog_context_t ctx;
//         asciilog_init_session_ctx(&ctx);
//
//         FILE* fp = fopen(...);
//         asciilog_set_output_FILE(&ctx, fp);
//
//         asciilog_emit_legend_ctx(&ctx);
//         ...
//         asciilog_set_field_value__a(...);
//         asciilog_set_field_value__b(...);
//         ...
//         asciilog_emit_record();
//     }
void _asciilog_init_ctx( struct asciilog_context_t* ctx,
                         int Nfields);

#ifdef __cplusplus
}
#endif

