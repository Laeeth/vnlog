* Summary
This should highlight the format and filtering tool FIRST. The C interface
second.


In a shell:

#+BEGIN_EXAMPLE
asciilog-gen-header 'int w' 'uint8_t x' 'char* y' 'double z' > asciilog_fields_generated.h
#+END_EXAMPLE

In a C program test.c:

#+BEGIN_SRC C
#include "asciilog_fields_generated.h"

int main()
{
    asciilog_emit_legend();

    asciilog_set_field_value__w(-10);
    asciilog_set_field_value__x(40);
    asciilog_set_field_value__y("asdf");
    asciilog_emit_record();

    asciilog_set_field_value__z(0.3);
    asciilog_set_field_value__x(50);
    asciilog_set_field_value__w(-20);
    asciilog_emit_record();

    asciilog_set_field_value__w(-30);
    asciilog_set_field_value__x(10);
    asciilog_set_field_value__y("whoa");
    asciilog_set_field_value__z(0.5);
    asciilog_emit_record();

    return 0;
}
#+END_SRC

Then we build and run, and we get

#+BEGIN_EXAMPLE
$ cc -o test test.c -lasciilog

$ ./test

# w x y z
-10 40 asdf -
-20 50 - 0.300000
-30 10 whoa 0.500000
#+END_EXAMPLE

Hot damn! Let's look only at the =w= and =x= columns

#+BEGIN_EXAMPLE
$ ./test | asciilog-filter w x

# w x
-10 40
-20 50
-30 10
#+END_EXAMPLE

We can trivially make plots:

#+BEGIN_EXAMPLE
$ ./test | asciilog-filter w x | feedgnuplot --domain --terminal 'dumb 80,20' --unset grid --lines --exit
                                                                                
  50 +-+---------------+--------------********------------+---------------+-+   
     +                 +            **   +    *********   +                 +   
  45 +-+                         ***                   ********           +-+   
     |                         **                              *********    |   
  40 +-+                    ***                                         *****   
     |                    **                                                |   
  35 +-+                **                                                +-+   
  30 +-+             ***                                                  +-+   
     |             **                                                       |   
  25 +-+        ***                                                       +-+   
     |        **                                                            |   
  20 +-+    **                                                            +-+   
     |   ***                                                                |   
  15 +-**                                                                 +-+   
     +*                +                 +                +                 +   
  10 *-+---------------+-----------------+----------------+---------------+-+   
    -30               -25               -20              -15               -10  
#+END_EXAMPLE

The field selectors fall back to regexes, and simple processing is available.
For instance, =w= relative to the first record:

#+BEGIN_EXAMPLE
$ ./test | asciilog-filter 'rel(w)' '[xy]'

# rel(w) x y
0 40 asdf
-10 50 -
-20 10 whoa
#+END_EXAMPLE

And we can ask for specific rows. Only those that have a valid record for =y=:

#+BEGIN_EXAMPLE
$ ./test | asciilog-filter --has y

# w x y z
-10 40 asdf -
-30 10 whoa 0.500000
#+END_EXAMPLE

Or those that match some arbitrary expression:

#+BEGIN_EXAMPLE
$ ./test | asciilog-filter --matches 'x > 20'

# w x y z
-10 40 asdf -
-20 50 - 0.300000
#+END_EXAMPLE

* Description
Asciilog is a trivially-simple log-file format that is tailored to work well
with standard UNIXy tools with common UNIXy workflows.

The log is composed of ASCII text with one data record per line and each record
composed of whitespace-separated fields, i.e. exactly like awk expects. Each
field has some specific meaning for all rows. Lines beginning with =#= are
comments. The first line that begins with =#= (but not =##=) is a legend line:
past the =#=, each field is a label for that field.

Common workflows include processing with awk or perl, plotting with feedgnuplot
or analyzing with numpy. Since this is extremely simple and standard, many
things are possible and easy.

This all can be trivially generated with printf and processed with awk, but we
provide a few tools for convenience:

- =asciilog-filter=
selects specific rows, fields possibly with some very simple postprocessing

- =asciilog-tailf=
Works like =tail -f=, but makes sure to output the legend

- =asciilog-align=
Works like =column -t= to print out aligned columns of text, but makes sure to
treat the legend and comments correctly

- =asciilog-make-matrix=
Converts a one-point-per-line asciilog to a matrix of data. I.e.

#+BEGIN_EXAMPLE
$ cat /tmp/dat
# i j x
0 0 1
0 1 2
0 2 3
1 0 4
1 1 5
1 2 6
2 0 7
2 1 8
2 2 9
3 0 10
3 1 11
3 2 12

$ </tmp/dat asciilog-filter i x | asciilog-make-matrix --outdir /tmp
Writing to '/tmp/x.matrix'

$ cat /tmp/x.matrix
1 2 3
4 5 6
7 8 9
10 11 12
#+END_EXAMPLE

- =asciilog.c=, =asciilog-gen-header=
a C interface so produce asciilog output. Allows the fields to be populated by
name, one at a time without the user needing to think about their column index

See [[file:asciilog.h][=asciilog.h=]] for the (trivially-simple) API. And see the manpages of each
specific tool to get more details about usage.

* Maintainer
This is maintained by Dima Kogan <Dmitriy.Kogan@jpl.nasa.gov>. Please let Dima
know if something is unclear/broken/missing

