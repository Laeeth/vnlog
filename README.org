* Summary

Vnlog (pronounced "vanillog") is a trivially-simple log format:

- A whitespace-separated table of ASCII human-readable text
- Lines beginning with =#= are comments
- The first line that begins with a single =#= (not =##=) is a /legend/, naming
  each column

Example:

#+BEGIN_EXAMPLE
## comment
# a b c
1 2 3
## another comment
4 5 6
#+END_EXAMPLE

Such data works very nicely with normal UNIX tools (=awk=, =sort=, =join=), can
be easily read by fancier tools (=numpy=, =matlab= (yuck), =excel= (YUCK), etc),
and can be plotted with =feedgnuplot=. This tookit provides some tools to
manipulate =vnlog= data and a few libraries to read/write it. The core
philosophy is to keep everything as simple and light as possible, and to provide
methods to enable existing (and familiar!) tools and workflows to be utilized in
nicer ways.

* Synopsis

In one terminal, sample the CPU temperature over time, and write the data to a
file as it comes in, at 1Hz:

#+BEGIN_EXAMPLE
$ ( echo '# time temp1 temp2 temp3';
    while true; do echo -n "`date +%s` "; < /proc/acpi/ibm/thermal awk '{print $2,$3,$4; fflush()}';
    sleep 1; done )
    > /tmp/temperature.vnl
#+END_EXAMPLE

In another terminal, I sample the consumption of CPU resources, and log /that/
to a file:

#+BEGIN_EXAMPLE
$ (echo "# user system nice idle waiting hardware_interrupt software_interrupt stolen";
   top -b -d1 | awk '/%Cpu/ {print $2,$4,$6,$8,$10,$12,$14,$16; fflush()}')
   > /tmp/cpu.vnl
#+END_EXAMPLE

These logs are now accumulating, and I can do stuff with them. The legend and
the last few measurements:

#+BEGIN_EXAMPLE
$ vnl-tail /tmp/temperature.vnl
# time temp1 temp2 temp3
1517986631 44 38 34
1517986632 44 38 34
1517986633 44 38 34
1517986634 44 38 35
1517986635 44 38 35
1517986636 44 38 35
1517986637 44 38 35
1517986638 44 38 35
1517986639 44 38 35
1517986640 44 38 34
#+END_EXAMPLE

I grab just the first temperature sensor, and align the columns

#+BEGIN_EXAMPLE
$ < /tmp/temperature.vnl vnl-tail |
    vnl-filter -p time,temp=temp1 |
    vnl-align
#  time    temp
1517986746 45
1517986747 45
1517986748 46
1517986749 46
1517986750 46
1517986751 46
1517986752 46
1517986753 45
1517986754 45
1517986755 45
#+END_EXAMPLE

I do the same, but read the log data in realtime, and feed it to a plotting tool
to get a live reporting of the cpu temperature. This plot updates as data comes
in. I then spin a CPU core (=while true; do true; done=), and see the
temperature climb. Here I'm making an ASCII plot that's pasteable into the docs.

#+BEGIN_EXAMPLE
$ < /tmp/temperature.vnl vnl-tail -f           |
    vnl-filter --unbuffered -p time,temp=temp1 |
     feedgnuplot --stream --domain
       --lines --timefmt '%s' --set 'format x "%M:%S"' --ymin 40
       --unset grid --terminal 'dumb 80,40'

  70 +----------------------------------------------------------------------+
     |      +      +      +      +       +      +      +      +      +      |
     |                                                                      |
     |                                                                      |
     |                                                                      |
     |                      **                                              |
  65 |-+                   ***                                            +-|
     |                    ** *                                              |
     |                    *  *                                              |
     |                    *  *                                              |
     |                   *   *                                              |
     |                  **   **                                             |
  60 |-+                *     *                                           +-|
     |                 *      *                                             |
     |                 *      *                                             |
     |                 *      *                                             |
     |                **      *                                             |
     |                *       *                                             |
  55 |-+              *       *                                           +-|
     |                *       *                                             |
     |                *       **                                            |
     |                *        *                                            |
     |               **        *                                            |
     |               *         **                                           |
  50 |-+             *          **                                        +-|
     |               *           **                                         |
     |               *            ***                                       |
     |               *              *                                       |
     |               *              ****                                    |
     |               *                 *****                                |
  45 |-+             *                     ***********                    +-|
     |    ************                               ********************** |
     |          * **                                                        |
     |                                                                      |
     |                                                                      |
     |      +      +      +      +       +      +      +      +      +      |
  40 +----------------------------------------------------------------------+
   21:00  22:00  23:00  24:00  25:00   26:00  27:00  28:00  29:00  30:00  31:00
#+END_EXAMPLE

Cool. I can then join the logs, pull out simultaneous CPU consumption and
temperature numbers, and plot the path in the temperature-cpu space:

#+BEGIN_EXAMPLE
$ vnl-join -j time /tmp/temperature.vnl /tmp/cpu.vnl |
  vnl-filter -p temp1,user                           |
  feedgnuplot --domain --lines
    --unset grid --terminal 'dumb 80,40'

  45 +----------------------------------------------------------------------+
     |           +           +           +          +           +           |
     |                                       *                              |
     |                                       *                              |
  40 |-+                                    **                            +-|
     |                                      **                              |
     |                                     * *                              |
     |                                     * *      *    *    *             |
  35 |-+               ****      *********** **** * **** ***  ******      +-|
     |        *********   ********       *   *  *****  *** * ** *  *        |
     |        *    *                            * * *  * * ** * *  *        |
     |        *    *                                   *   *  *    *        |
  30 |-+      *                                                    *      +-|
     |        *                                                    *        |
     |        *                                                    *        |
     |        *                                                    *        |
  25 |-+      *                                                    *      +-|
     |        *                                                    *        |
     |        *                                                    *        |
     |        *                                                    *        |
  20 |-+      *                                                    *      +-|
     |        *                                                    *        |
     |        *                                                    *        |
     |      * *                                                    *        |
  15 |-+    * *  *                                                 *      +-|
     |      * *  *                                                 *        |
     |      ***  *                                                 *        |
     |      ***  *                                                 *        |
  10 |-+    ***  *                                                 *      +-|
     |      ***  *                                                 *        |
     |      ***  *                                                 *        |
     |      ***  *                                                 *        |
   5 |-+    ***  *                                                 *      +-|
     |      ***  *                                                 *        |
     |      * *  * *                                               *        |
     |      **** * ** *****  *********** +       *******       *****        |
   0 +----------------------------------------------------------------------+
     40          45          50          55         60          65          70
#+END_EXAMPLE

* Description

As stated before, vnlog tools are designed to be very simple and light. There
exist other tools that are similar. For instance:

    https://csvkit.readthedocs.io/
    https://github.com/johnkerl/miller
    https://github.com/eBay/tsv-utils-dlang

These all provide facilities to run various analyses, and are neither simple nor
light. Vnlog by contrast doesn't analyze anything, but makes it easy to write
simple bits of awk or perl to process stuff to your heart's content. The main
envisioned use case is one-liners, and the tools are geared for that purpose.

In the spirit of doing as little as possible, the provided tools are wrappers
around tools you already have and are familiar with. The provided tools are:

- =vnl-filter= is a tool to select a subset of the rows/columns in a vnlog
  and/or to manipulate the contents. This is effectively an =awk= wrapper where
  the fields can be referenced by name instead of index. 20-second tutorial:

#+BEGIN_EXAMPLE
vnl-filter -p col1,col2,colx=col3+col4 'col5 > 10' --has col6
#+END_EXAMPLE
  will read the input, and produce a vnlog with 3 columns: =col1= and =col2=
  from the input and a column =colx= that's the sum of =col3= and =col4= in the
  input. Only those rows for which the =col5 > 10= is true will be output.
  Finally, only those rows that have a non-null value for =col6= will be
  selected. A null entry is signified by a single =-= character.

#+BEGIN_EXAMPLE
vnl-filter --eval '{s += x} END {print s}'
#+END_EXAMPLE
  will evaluate the given awk program on the input, but the column names work as
  you would hope. I.e. if the input has a column named =x=, this would produce
  the sum of all values in this column.

- =vnl-sort=, =vnl-join=, =vnl-tail= are wrappers around the corresponding GNU
  Coreutils tools. These work exactly as you would expect also: the columns can
  be referenced by name, and the legend comment is handled properly. These are
  wrappers, so all the commandline options those tools have "just work" (except
  options that don't make sense in the context of vnlog). As an example,
  =vnl-tail -f= will follow a log: data will be read by =vnl-tail= as it is
  written into the log. And you already know how to use these tools without even
  reading the manpages!

- =vnl-align= aligns vnlog columns for easy interpretation by humans. The
  meaning is unaffected

- =Vnlog::Parser= is a simple perl library to read a vnlog

- =libvnlog= is a C library to simplify writing a vnlog. Clearly all you really
  need is =printf()=, but this is useful if we have lots of columns, many
  containing null values in any given row, and/or if we have parallel threads
  writing to a log

- =vnl-make-matrix= converts a one-point-per-line vnlog to a matrix of data.
  I.e.

#+BEGIN_EXAMPLE
$ cat dat.vnl
# i j x
0 0 1
0 1 2
0 2 3
1 0 4
1 1 5
1 2 6
2 0 7
2 1 8
2 2 9
3 0 10
3 1 11
3 2 12

$ < dat.vnl vnl-filter -p i,x | vnl-make-matrix --outdir /tmp
Writing to '/tmp/x.matrix'

$ cat /tmp/x.matrix
1 2 3
4 5 6
7 8 9
10 11 12
#+END_EXAMPLE

All the tools have manpages that contain more detail. And tools will probably be
added with time.


* C interface

For most uses, these logfiles are simple enough to be generated with plain
prints. But then each print statement has to know which numeric column we're
populating, which becomes effortful with many columns. In my usage it's common
to have a large parallelized C program that's writing logs with hundreds of
columns where any one record would contain only a subset of the columns. In such
a case, it's helpful to have a library that can output the log files. This is
available, and simple-enough to be demonstrated with an example:

In a shell:

#+BEGIN_EXAMPLE
$ vnl-gen-header 'int w' 'uint8_t x' 'char* y' 'double z' > vnlog_fields_generated.h
#+END_EXAMPLE

In a C program test.c:

#+BEGIN_SRC C
#include "vnlog_fields_generated.h"

int main()
{
    vnlog_emit_legend();

    vnlog_set_field_value__w(-10);
    vnlog_set_field_value__x(40);
    vnlog_set_field_value__y("asdf");
    vnlog_emit_record();

    vnlog_set_field_value__z(0.3);
    vnlog_set_field_value__x(50);
    vnlog_set_field_value__w(-20);
    vnlog_emit_record();

    vnlog_set_field_value__w(-30);
    vnlog_set_field_value__x(10);
    vnlog_set_field_value__y("whoa");
    vnlog_set_field_value__z(0.5);
    vnlog_emit_record();

    return 0;
}
#+END_SRC

Then we build and run, and we get

#+BEGIN_EXAMPLE
$ cc -o test test.c -lvnlog

$ ./test

# w x y z
-10 40 asdf -
-20 50 - 0.300000
-30 10 whoa 0.500000
#+END_EXAMPLE

* Repository

https://github.com/dkogan/vnlog/

* Author

Dima Kogan =dima@secretsauce.net=

* License and copyright

This library is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at your option) any
later version.

Copyright 2016-2017 California Institute of Technology
Copyright 2017-2018 Dima Kogan =dima@secretsauce.net=
