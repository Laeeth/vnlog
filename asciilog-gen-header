#!/usr/bin/perl
use strict;
use warnings;

use feature ':5.10';
use String::ShellQuote;



if(!@ARGV)
{
    die "Need at least one field spec on the cmdline";
}

my $argstring = shell_quote(@ARGV);
my $Nfields   = @ARGV;


say <<EOF;
// Generated by
//     $0 $argstring

#pragma once

#include <inttypes.h>

#define ASCIILOG_N_FIELDS $Nfields
#include <asciilog/asciilog.h>

EOF


my $legend = "#";

for my $field(@ARGV)
{
    my ($set_field_value, $name) = gen_field($field);
    print $set_field_value;

    $legend .= " $name";
}

say <<EOF;


#define asciilog_emit_legend()        _asciilog_emit_legend(\"$legend\\n\", ASCIILOG_N_FIELDS)
#define asciilog_emit_record_ctx(ctx) _asciilog_emit_record(ctx,  ASCIILOG_N_FIELDS)
#define asciilog_emit_record()        _asciilog_emit_record(NULL, ASCIILOG_N_FIELDS)
#define asciilog_clear_ctx(ctx)       _asciilog_clear_ctx(ctx,  ASCIILOG_N_FIELDS)
#define asciilog_clear()              _asciilog_clear_ctx(NULL, ASCIILOG_N_FIELDS)
EOF



sub gen_field
{
    my ($field) = @_;

    state $idx = 0;

    my %fmt_type =
      (
       'int'          => '"%d"',
       'int8_t'       => '"%" PRId8',
       'int16_t'      => '"%" PRId16',
       'int32_t'      => '"%" PRId32',
       'int64_t'      => '"%" PRId64',
       'unsigned int' => '"%u"',
       'unsigned'     => '"%u"',
       'uint8_t'      => '"%" PRIu8',
       'uint16_t'     => '"%" PRIu16',
       'uint32_t'     => '"%" PRIu32',
       'uint64_t'     => '"%" PRIu64',
       'char'         => '"%c"',
       'double'       => '"%f"',
       'const char*'  => '"%s"',
       'char*'        => '"%s"'
      );

    my ($type, $name) = $field =~ /\s*
                                   (.+?) # A maximal string. May have space in the middle
                                   \s+   # Some space
                                   (\S+) # A maximal string with no spaces
                                  /x;
    if( !defined $type || !defined $name )
    {
        die "Couldn't parse field spec '$field'";
    }

    if( $name =~ /[^a-zA-Z0-9_]/ )
    {
        die "Name can only have [a-zA-Z0-9_], but got '$name'";
    }

    $type =~ s/ +/ /g;   # replace all consecutive ' ' with a single space
    $type =~ s/ \*/\*/g; # ' *' -> '*'. so 'const char *' -> 'const char*'

    my $fmt = $fmt_type{$type} or die "Unknown type '$type'. I only know about " . join(' ', keys %fmt_type);

    my $set_field_value = <<EOF;
#define asciilog_set_field_value_ctx__$name(ctx, x) _asciilog_set_field_value(ctx,  "$name", $idx, $fmt, x)
#define asciilog_set_field_value__$name(x)          _asciilog_set_field_value(NULL, "$name", $idx, $fmt, x)
EOF

    $idx++;

    return ($set_field_value, $name);
}

__END__

=head1 NAME

asciilog-gen-header - create definition for asciilog output from C

=head1 SYNOPSIS

 $ asciilog-gen-header 'int w' 'uint8_t x' 'char* y' 'double z' > asciilog_fields_generated.h

=head1 DESCRIPTION

We provide a simple C library to produce asciilog output. The fields this
library outputs must be known at compile time, and are specified in a header
created by this tool. Please see the asciilog documentation for instructions on
how to use the library

=head1 REQUIRED ARGUMENTS

Each commandline argument represents a single output field. Each such field spec
in a C-style variable declaration with a type followed by a name. Note that
these field specs contain whitespace, so each one must be quoted before being
passed to the shell.

The types can be basic scalars, possibly with set widths (C<char>, C<double>,
C<int>, C<uint32_t>, C<unsigned int>, ...), or a NULL-terminated string
(C<char*>).

The names must consist entirely of letters, numbers or C<_>, like variables in
C.

=head1 REPOSITORY

https://github.jpl.nasa.gov/maritime-robotics/asciilog/

=head1 AUTHOR

Dima Kogan C<< <Dmitriy.Kogan@jpl.nasa.gov> >>

=head1 LICENSE AND COPYRIGHT

Proprietary. Copyright 2016 California Institute of Technology
