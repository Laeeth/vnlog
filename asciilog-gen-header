#!/usr/bin/perl
use strict;
use warnings;

use feature ':5.10';
use String::ShellQuote;


# input can come on the commandline, or pipe in on STDIN
my @defs; # field definitions. Each element is "type name"
if(@ARGV)
{
    @defs = @ARGV;
}
else
{
    # each line is a definition.
    # cut off trailing whitespace
    # ignore comments and any blank lines
    @defs = grep {!/^\s*#/ && /\S/ } map {chomp; $_;} <>;
}

if(!@defs)
{
    say STDERR "Field definitions must come on the commandline or on STDIN";
    exit 1;
}


my $legend = "#";

my $set_field_value_defs = '';
for my $field(@defs)
{
    my ($set_field_value, $name) = gen_field($field);
    $set_field_value_defs .= $set_field_value;
    $legend .= " $name";
}

my $argstring = shell_quote(@defs);
my $Nfields   = @defs;


say <<EOF;
// Generated by
//     $0 $argstring

#pragma once

#include <inttypes.h>

#define ASCIILOG_N_FIELDS         $Nfields
#include <asciilog/asciilog.h>

EOF

print $set_field_value_defs;

say <<EOF;
#define asciilog_emit_legend_ctx(ctx)  _asciilog_emit_legend(ctx,  \"$legend\\n\", ASCIILOG_N_FIELDS)
#define asciilog_emit_legend()         _asciilog_emit_legend(NULL, \"$legend\\n\", ASCIILOG_N_FIELDS)
#define asciilog_free_ctx(ctx)  _asciilog_free_ctx(ctx, ASCIILOG_N_FIELDS)
EOF



sub gen_field
{
    my ($field) = @_;

    state $idx = 0;

    my %fmt_type =
      (
       'int'          => '"%d"',
       'int8_t'       => '"%" PRId8',
       'int16_t'      => '"%" PRId16',
       'int32_t'      => '"%" PRId32',
       'int64_t'      => '"%" PRId64',
       'unsigned int' => '"%u"',
       'unsigned'     => '"%u"',
       'uint8_t'      => '"%" PRIu8',
       'uint16_t'     => '"%" PRIu16',
       'uint32_t'     => '"%" PRIu32',
       'uint64_t'     => '"%" PRIu64',
       'char'         => '"%c"',
       'float'        => '"%f"',
       'double'       => '"%f"',
       'const char*'  => '"%s"',
       'char*'        => '"%s"'
      );

    my ($type, $name, $options) =
      $field =~ /\s*
                 (.+?) # A maximal string. May have space in the middle
                 \s+   # Some space
                 (\S+) # A maximal string with no spaces
                 (?:
                     \s*
                     \(\s* (.*?) \s* \) # some expression in () ...
                 )?                     # ... possibly missing
                /x;
    if ( !defined $type || !defined $name )
    {
        die "Couldn't parse field spec '$field'";
    }
    if( defined $options  )
    {
        die "No options are yet supported";
    }
    if( $name =~ /[^a-zA-Z0-9_]/ )
    {
        die "Name can only have [a-zA-Z0-9_], but got '$name'";
    }

    $type =~ s/ +/ /g;   # replace all consecutive ' ' with a single space
    $type =~ s/ \*/\*/g; # ' *' -> '*'. so 'const char *' -> 'const char*'

    my @ret;
    if( $type eq 'void*' )
    {
        # binary type
        my $set_field_value = <<EOF;
#define asciilog_set_field_value_ctx__$name(ctx, ptr, len) _asciilog_set_field_value_binary(ctx,  "$name", $idx, ptr, len)
#define asciilog_set_field_value__$name(ptr, len)          _asciilog_set_field_value_binary(NULL, "$name", $idx, ptr, len)
EOF

        @ret = ($set_field_value, $name);
    }
    else
    {
        my $fmt = $fmt_type{$type} or die "Unknown type '$type'. I only know about " . join(' ', keys %fmt_type);

        my $set_field_value;
        my ($type_footer, $type_arg);
        if ( $type =~ /double|float/ )
        {
            $type_footer = "double";
            $type_arg    = "(double)(x)";
        }
        else
        {
            my $otype = '__' . ($type =~ s/ /_/gr =~ s/char\*/str/gr);
            $type_footer = "int";
            $type_arg    = "(union asciilog_field_types_t){.$otype = (x)}";
        }

        $set_field_value = <<EOF;
#define asciilog_set_field_value_ctx__$name(ctx, x) _asciilog_set_field_value_${type_footer}(ctx,  "$name", $idx, $fmt, $type_arg)
#define asciilog_set_field_value__$name(x)          _asciilog_set_field_value_${type_footer}(NULL, "$name", $idx, $fmt, $type_arg)
EOF

        @ret = ($set_field_value, $name);
    }

    $idx++;
    return @ret;
}

__END__

=head1 NAME

asciilog-gen-header - create definition for asciilog output from C

=head1 SYNOPSIS

 $ asciilog-gen-header 'int w' 'uint8_t x' 'char* y' 'double z' > asciilog_fields_generated.h

=head1 DESCRIPTION

We provide a simple C library to produce asciilog output. The fields this
library outputs must be known at compile time, and are specified in a header
created by this tool. Please see the asciilog documentation for instructions on
how to use the library

=head1 ARGUMENTS

This tool needs to be given a list of field definitions. First we look at the
commandline, and if the definitions are not available there, we look on STDIN.
Each definition is a string C<type name> (one def per argument on the
commandline or per line on STDIN). If reading from STDIN, we ignore blank lines,
and treat any line starting with C<#> as a comment.

Each def represents a single output field. Each such field spec in a C-style
variable declaration with a type followed by a name. Note that these field specs
contain whitespace, so each one must be quoted before being passed to the shell.

The types can be basic scalars, possibly with set widths (C<char>, C<double>,
C<int>, C<uint32_t>, C<unsigned int>, ...), or a NULL-terminated string
(C<char*>).

The names must consist entirely of letters, numbers or C<_>, like variables in
C.

=head1 REPOSITORY

https://github.jpl.nasa.gov/maritime-robotics/asciilog/

=head1 AUTHOR

Dima Kogan C<< <Dmitriy.Kogan@jpl.nasa.gov> >>

=head1 LICENSE AND COPYRIGHT

Proprietary. Copyright 2016 California Institute of Technology
