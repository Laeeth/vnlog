#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use List::Util 'max';
use List::MoreUtils 'all';

use feature qw(say state);


my $usage = "$0 [--dumpindices] [--has c0,c1,...] [--has c2] [--noskipempty] [--skipcomments] ... c3 c4 f(c0) g(c1) ...\n";
if(! @ARGV)
{
    die $usage;
}

# by default we do skip empty records
my %options = (skipempty => 1);
GetOptions(\%options,
           "has=s@",
           "skipempty!",
           "skipcomments!",
           "dumpindices!",
           "help") or die($usage);

if( defined $options{help} )
{
    print $usage;
    exit 0;
}

# useful for realtime plots
autoflush STDOUT;

my @cols_want = @ARGV;
my @must_have_col_indices;

# parse the , in $options{has}
my @must_have_col_names;
$options{has} //= [];
for my $c (@{$options{has}})
{
    push @must_have_col_names, split(/,/,$c)
}

# if no columns requested, just print everything
if( !@cols_want && !@must_have_col_names )
{
    while(<STDIN>)
    { print; }
}

# script to read intersense logs and to only select particular columns
my @indices = ();
my $indices_max;


my @transforms;

RECORD:
while(<STDIN>)
{
    if(/^##/p)
    {
        print unless $options{skipcomments};
        next;
    }

    if( /^#/p )
    {
        next if @indices;

        chomp;

        # we got a legend line
        my @cols_all_legend = split ' ', ${^POSTMATCH}; # split the field names (sans the #)

        # If we weren't asked for particular columns, take them all. This isn't
        # a no-op because we can have --has
        @cols_want = @cols_all_legend unless @cols_want;

        my @colnames_output;


        # grab all the column indices
      COLUMN:
        foreach my $col_want (@cols_want)
        {
            my @funcs;

            my $accept = sub
            {
                my @indices_here = @_;

                my $Nindices = @indices;

                push @colnames_output, @cols_all_legend[@indices_here];
                push @indices,         @indices_here;

                if( @funcs )
                {
                    # This loop is important. It is possible to push it to later
                    # by doing this instead:
                    #
                    #   push @transforms, [\@indices_here, parse_transform_funcs(@funcs) ];
                    #
                    # but then all of @indices_here will get a single
                    # transformation subroutine object, and all of its internal
                    # state will be shared, which is NOT what you want. For
                    # instance if we're doing rel(.*time) or something, then the
                    # initial timestamp would be shared. This is wrong.
                    #
                    # The indices here index the OUTPUT columns list
                    foreach my $idx (0..$#indices_here)
                    {
                        push @transforms, [$idx + $Nindices, parse_transform_funcs(@funcs) ];

                        $colnames_output[$idx + $Nindices] =
                          join('', map { "$_("} reverse @funcs) .
                          $colnames_output[$idx + $Nindices] .
                          ')' x scalar(@funcs);
                    }
                }
            };


            my @indices_here;

            # do I have an exact column match?
            @indices_here = grep {$col_want eq $cols_all_legend[$_]} 0..$#cols_all_legend;
            if ( @indices_here > 1 )
            {
                die "Found more than one column that string-matched '$col_want' exactly";
            }
            if ( @indices_here == 1 )
            {
                $accept->(@indices_here);
                next;
            }

            # I look for any requested functions. These all look like "f(x)" and
            # may be nested. f(g(h(x))) is allowed. At each function level, I
            # look for exact matching columns. I.e. if I'm asked about
            # "diff(rel(x))" it is possible that I should find a column "x" and
            # then rel() it and then diff() it; it's also possible that I should
            # find a column "rel(x)" and then diff() it
            while($col_want =~ /^           # start
                                ( [^\(]+ )  # Function name. Non-( characters
                                \( (.+) \)  # Function arg
                                $           # End
                               /x)
            {
                unshift @funcs, $1;
                $col_want = $2;

                # do I have an exact column match now?
                @indices_here = grep {$col_want eq $cols_all_legend[$_]} 0..$#cols_all_legend;
                if ( @indices_here > 1 )
                {
                    die "Found more than one column that string-matched '$col_want' exactly";
                }
                if ( @indices_here == 1 )
                {
                    $accept->(@indices_here);
                    next COLUMN;
                }

            }

            # I'm done looking for transformations, and no exact matches were
            # found. I know there aren't any more '()' in the string, so I try a
            # regex
            @indices_here = grep {$cols_all_legend[$_] =~ qr/$col_want/} 0..$#cols_all_legend;
            if( @indices_here >= 1 )
            {
                $accept->(@indices_here);
                next;
            }

            die "Couldn't find requested column '$col_want' in the legend line '$_'";
        }

        $indices_max = max @indices;

        if ( $options{dumpindices} )
        {
            print "@indices\n";
            exit;
        }

        # print out the new legend
        print "# @colnames_output\n";


        if( @must_have_col_names )
        {
            my %colindices;
            foreach my $idx (0..$#cols_all_legend)
            {
                $colindices{$cols_all_legend[$idx]} = $idx;
            }

            foreach my $col (@must_have_col_names)
            {
                if( !defined $colindices{$col})
                {
                    die "I don't have column '$col'";
                }
                push @must_have_col_indices, $colindices{$col};
            }
        }

        next;
    }

    # we got a data line
    next if $options{dumpindices};

    # select the columns we want
    chomp;
    my @f = split;

    # skip incomplete lines. Can happen if a log line at the end of a file was
    # cut off in the middle
    next unless $indices_max <= $#f;

    if(@must_have_col_indices)
    {
        for my $idx (@must_have_col_indices)
        {
            next RECORD if '-' eq $f[$idx];
        }
    }

    @f = @f[@indices];

    next if $options{skipempty} && all {$_ eq '-' } @f;

    for my $transform (@transforms)
    {
        # The indices here index the OUTPUT columns list
        my ($idx, @funcs) = @$transform;

        foreach my $func(@funcs)
        {
            $f[$idx] = $func->($f[$idx]);
        }
    }

    print "@f\n";
}






sub parse_transform_funcs
{
    sub parse_transform_func
    {
        my $f = shift;

        if( $f eq 'us2s' )
        {
            return sub { return $_[0] * 1e-6; };
        }
        elsif( $f eq 'deg2rad' )
        {
            return sub { return $_[0] * 3.141592653589793/180.0; };
        }
        elsif( $f eq 'rad2deg' )
        {
            return sub { return $_[0] * 180.0/3.141592653589793; };
        }
        elsif( $f eq 'rel' )
        {
            # relative to the starting value. The 'state' variable should be a
            # different instance for each sub instance
            return sub
            {
                state $x0;
                $x0 //= $_[0];
                return $_[0] - $x0;
            };
        }
        elsif( $f eq 'diff' )
        {
            # relative to the previous value. The 'state' variable should be a
            # different instance for each sub instance
            return sub
            {
                state $xprev;
                my $ret = 0;
                if(defined $xprev)
                {
                    $ret = $_[0] - $xprev;
                }
                $xprev = $_[0];
                return $ret;
            };
        }
        else
        {
            die "Unknown transform function '$f'";
        }
    }


    my @funcs = @_;
    return map { parse_transform_func($_) } @funcs;
}

__END__

=head1 NAME

asciilog-filter - filters ascii logs to select particular rows, fields

=head1 SYNOPSIS

    # Read log data, filter out the timestamps, and post-process some of them
    $ raw-log-read-ins /tmp/stereo_lump_log |
      asciilog-filter '.*time' 'us2s(time)' 'rel(time)' 'rel(us2s(.*time))'

    # frame_time time us2s(time) rel(time) rel(us2s(frame_time)) rel(us2s(time))
    1434662133270338 1434662131279978 1434662131.27998 0 0 0
    1434662133270338 1434662131289978 1434662131.28998 10000 0 0.00999999046325684
    1434662133270338 1434662131299978 1434662131.29998 20000 0 0.0199999809265137
    1434662133270338 1434662131309978 1434662131.30998 30000 0 0.0299999713897705
    ...

    # Read log data, filter out the lat/lon, and make a plot
    $ raw-log-read-ins /tmp/stereo_lump_log |
      asciilog-filter lat lon |
      feedgnuplot --domain --lines

    [ plot pops up ]


=head1 DESCRIPTION

This tool reads in an ASCII data stream, and allows easy filtering to select
particular data from this stream. Many common post-processing operations are
available.

This is a UNIX-style tool, so the input/output of this tool is strictly
STDIN/STDOUT. Furthermore, this tool is a filter, so the format of the output is
I<exactly> the same as the format of the input.

This tool is convenient both to filter stored data, or to filter live data that
can then be plotted to produce realtime telemetry.

This tool takes a list of fields on the commandline. These are the only fields
that are selected for output. The requested field names are compared with the
fields listed in the legend of the data. If an exact match is found, we select
that column. Otherwise we run a regex search, and take all matching columns.

The user often wants to apply unit conversions to data, or to look at the data
relative to the initial point, or to differentiate the input. These filters can
be easily applied by this tool.

=head2 Input/output data format

The input/output data is simply an ASCII table of values. Any lines beginning
with C<##> are treated as comments, and are passed through. The first line that
begins with C<#> but not C<##> is a I<legend> line. After the C<#>, follow
whitespace-separated ASCII field names. Each subsequent line is
whitespace-separated values matching this legend. For instance, this is a valid
data file:

    ## log version: 3 ins_type: RAW_LOG_INS_440 camera_type: Unknown camera_type id: 5
    ## camera 0: serial 0,1 cols/rows: 3904 3904 channels: 1 depth: 8
    ## camera 1: serial 2,3 cols/rows: 3904 3904 channels: 1 depth: 8
    ## camera 2: serial 4,0 cols/rows: 3904 3904 channels: 1 depth: 8
    ## camera 3: serial 0,0 cols/rows: 0 0 channels: 0 depth: 0
    # x_rate y_rate z_rate
    -0.016107 0.004362 0.005369
    -0.017449 0.006711 0.006711
    -0.018456 0.014093 0.006711
    -0.017449 0.018791 0.006376

This is the format for both the input and the output. This tool makes sure to
update the legend to reflect which columns have been selected.

A string C<-> is used to indicate that a record does not have a value for this
field. Other records (lines) may have such a value.

=head2 Filters

We can post-process our data with filters. To apply filter =f= and then filter
=g= to column =x=, pass in =g(f(x))=. The filters currently available are

=over

=item C<us2s>

convert microseconds to seconds

=item C<deg2rad>

convert degrees to radians

=item C<rad2deg>

convert radians to degrees

=item C<rel>

report data relative to first value

=item C<diff>

report data relative to previous value

=back

=head1 ARGUMENTS

=head2 --has a,b,c,...

A I<null> value in a column is designated with a single C<->. This means that
this particular field value does not exist in this record. If we want to select
only records that I<do> have a column named C<x>, we can pass C<--has x>. The
C<--has> option can be repeated to request multiple columns, or the multiple
columns can be given in a whitespace-less comma-separated list. For instance if
we want only recors that have both columns C<x> and C<y> we can pass in C<--has
x,y>.

=head2 --[no]skipempty

Do [not] skip records where all fields are blank. By default we I<do> skip all
empty records; to include them, pass C<--noskipempty>

=head2 --skipcomments

Don't output non-legend comments

=head2 --dumpindices

This option exists only for debugging. If given, prints out the indices of all
the selected columns, and exits.

=head1 REPOSITORY

https://github.jpl.nasa.gov/maritime-robotics/asciilog/

=head1 AUTHOR

Dima Kogan C<< <Dmitriy.Kogan@jpl.nasa.gov> >>

=head1 LICENSE AND COPYRIGHT

Proprietary. Copyright 2016 California Institute of Technology
