#!/usr/bin/perl
use strict;
use warnings;
use feature 'say';
use autodie;

use Getopt::Long 'GetOptionsFromArray';
use FindBin '$Bin';
use lib "$Bin/lib";
use Asciilog::Parser;

use Data::Dumper;
use Fcntl qw(F_GETFD F_SETFD F_DUPFD FD_CLOEXEC);



use Asciilog::Util 'get_unbuffered_line';




Getopt::Long::Configure('gnu_getopt');




sub open_file_as_pipe
{
    my ($filename) = @_;

    if($filename eq '-')
    {
        return *STDIN;
    }

    my $fh;
    if( ! -r $filename )
    {
        die "'$filename' is not readable";
    }

    # This invocation of 'cat' is important. I want to read the legend in this
    # perl program, and then exec the underlying application, with the inner
    # application using the post-legend file-descriptor. Conceptually this
    # works, BUT the inner application expects to get a filename that it calls
    # open() on, NOT an already-open file-descriptor. I can get an open-able
    # filename from /dev/fd/N, but on Linux this is a plain symlink to the
    # actual file, so the file would be re-opened, and the legend visible again.
    # By using a cat, /dev/fd/N is a pipe, not a file. And opening this pipe
    # DOES start reading the file from the post-legend location
    open $fh, '-|', "grep -v '^ *##' '$filename'";
    if( !$fh )
    {
        die "Couldn't open file '$filename'";
    }

    # I'm explicitly passing these to an exec, so FD_CLOSEXEC must be off
    my $fd    = fileno $fh;
    my $flags = fcntl $fh, F_GETFD, 0;
    fcntl $fh, F_SETFD, ($flags & ~FD_CLOEXEC);

    return $fh;
}

sub pull_key
{
    my ($input) = @_;
    my $filename = $input->{filename};
    my $fh       = $input->{fh};

    my $keys;

    my $parser = Asciilog::Parser->new();
    while (defined ($_ = get_unbuffered_line($fh)))
    {
        if ( !$parser->parse($_) )
        {
            die "Reading '$filename': Error parsing asciilog line '$_': " . $parser->error();
        }

        $keys = $parser->getKeys();
        if(defined $keys)
        {
            return $keys;
        }
    }

    return die "Reading '$filename': no legend found!";
}

sub parse_options
{
    my ($ARGV, $specs) = @_;

    my %options;
    my @ARGV_copy = @$ARGV;
    my $result;

    eval
    {
        $result =
          GetOptionsFromArray( \@ARGV_copy,
                               \%options,
                               @$specs );
    };

    if( $@  )
    {
        die "Error parsing options: '$@'";
    }
    if( !$result  )
    {
        die "Error parsing options";
    }

    push @ARGV_copy, '-' unless @ARGV_copy;
    return (\@ARGV_copy, \%options);
}

sub legends_match
{
    my ($l1, $l2) = @_;

    return 0 if scalar(@$l1) != scalar(@$l2);
    for my $i(0..$#$l1)
    {
        return 0 if $l1->[$i] ne $l2->[$i];
    }
    return 1;
}
sub ensure_all_legends_equivalent
{
    my ($inputs) = @_;

    for my $i(1..$#$inputs)
    {
        if(!legends_match($inputs->[0 ]{keys},
                          $inputs->[$i]{keys}))
        {
            die("All input legends must match! Instead files '$inputs->[0 ]{filename}' and '$inputs->[$i]{filename}' have keys " .
               "'@{$inputs->[0 ]{keys}}' and '@{$inputs->[$i]{keys}}' respectively");
        }
    }
    return 1;

}
sub interpret_argv
{
    my ($ARGV, $specs) = @_;

    my ($filenames,$options) = parse_options($ARGV, $specs);
    my @inputs = map { {filename => $_} } @$filenames;
    for my $input(@inputs)
    {
        $input->{fh}   = open_file_as_pipe($input->{filename});
        $input->{keys} = pull_key($input);
    }

    return (\@inputs, $options);
}




# This comes from the struct option long_options in sort.c in GNU coreutils
my @specs = ( # options with no args
              "ignore-leading-blanks|b",
              "debug",
              "dictionary-order|d",
              "ignore-case|f",
              "general-numeric-sort|g",
              "ignore-nonprinting|i",
              "merge|m",
              "month-sort|M",
              "numeric-sort|n",
              "human-numeric-sort|h",
              "version-sort|V",
              "random-sort|R",
              "reverse|r",
              "stable|s",
              "unique|u",
              "zero-terminated|z",

              # options with args
              "compress-program=s",
              "files0-from=s",
              "key|k=s",
              "random-source=s",
              "sort=s",
              "output|o=s",
              "batch-size=s",
              "buffer-size|S=s",
              "field-separator|t=s",
              "temporary-directory|T=s",
              "parallel=s",

              # special-case options. Kinda take args
              "check:s",
              "c|C",

              "help");

sub substitute_field_keys
{
    my ($options, $keys) = @_;

    my %key_indices;
    for my $i(0..$#$keys)
    {
        $key_indices{$keys->[$i]} = $i + 1; # sort indexes from 1
    }

    # manpage of sort says that key definitions are given as
    # "F[.C][OPTS][,F[.C][OPTS]]"
    my @keyspecs = split(',', $options->{key});

    $options->{key} =
      join(',',
           map
           {
               /^([^\.]+)(\..+)?$/ or die "Couldn't parse '$_' as a sort KEYDEF";

               my $extra = $2 // '';
               if (!exists $key_indices{$1})
               {
                   die "Requested key '$1' not found in the input asciilogs. Have known keys '@$keys'";
               }

               $key_indices{$1} . $extra;
           }
           @keyspecs);
}
sub reconstruct_substituted_command
{
    # reconstruct the command, invoking the internal GNU tool, but replacing the
    # filenames with the opened-and-read-past-the-legend pipe. The field
    # specifiers have already been replaced with their column indices
    my ($inputs, $options, $specs) = @_;

    my @argv;

    # First I pull in the arguments
    for my $option(keys %$options)
    {
        my $re_specs_noarg    = qr/^ $option (?: \| [^=:] + )*   $/x;
        my $re_specs_yesarg   = qr/^ $option (?: \| [^=:] + )* =  /x;
        my $re_specs_maybearg = qr/^ $option (?: \| [^=:] + )* :  /x;

        my @specs_noarg    = grep { /$re_specs_noarg/    } @$specs;
        my @specs_yesarg   = grep { /$re_specs_yesarg/   } @$specs;
        my @specs_maybearg = grep { /$re_specs_maybearg/ } @$specs;

        if( scalar(@specs_noarg) + scalar(@specs_yesarg) + scalar(@specs_maybearg) != 1)
        {
            die "Couldn't uniquely figure out where '$option' came from. This is a bug. Specs: '@$specs'";
        }

        if( @specs_noarg )
        {
            push @argv, "--$option";
        }
        elsif( @specs_yesarg )
        {
            my $value = $options->{$option};
            push @argv, "--$option=$value";
        }
        else
        {
            # optional arg. Value of '' means "no arg"
            my $value = $options->{$option};
            if( $value eq '')
            {
                push @argv, "--$option";
            }
            else
            {
                push @argv, "--$option=$value";
            }
        }
    }

    # And then I pull in the files
    push @argv, map { my $fd = fileno $_->{fh}; "/dev/fd/$fd" } @$inputs;

    return \@argv;
}

my ($inputs, $options) = interpret_argv( \@ARGV, \@specs );
ensure_all_legends_equivalent($inputs);
substitute_field_keys($options, $inputs->[0]{keys});
my $ARGV_new = reconstruct_substituted_command($inputs, $options, \@specs);

# say Dumper $inputs;
# say Dumper $options;
# say Dumper $ARGV_new;

say '# ' . join(' ', @{$inputs->[0]{keys}});
exec 'sort', @$ARGV_new;


__END__


#   {GETOPT_HELP_OPTION_DECL},
#   {GETOPT_VERSION_OPTION_DECL},

# my %opts = interpret_argv(\@ARGV, $specs);








# parse commandline to find all non-option args
#
# open all these as files, and read in all the legend lines
#
# exec and pass the open FDs on









# finish docs
# get this working with files on the cmdline, not just with stdin
# bsd sort?
# fancy --key specs
# interstitial comments?
# comm, cut, sort, join, paste, split






__END__

=head1 NAME

asciilog-sort - sorts a log file, preserving the legend

=head1 SYNOPSIS

 $ asciilog-sort tst.asciilog
 # x y z
 1 2 3
 ...

=head1 DESCRIPTION

The basic usage is

 asciilog-sort [arguments passed to sort] logfile

The last argument is assumed to be the log file, and all the preceding arguments
are passed to <sort> verbatim.

A common asciilog use case is to run a data-generating process, C<tee> the
output to a log file, while plotting some of the results:

 $ run_widget | tee tst.asciilog | asciilog-filter quality | feedgnuplot --stream

As this runs, maybe we want to make a realtime plot of some other fields in teh
log. We thus need to create a pipe that produces the data as it comes in.
Generall the C<sort> tool can do this if invoked with the C<-f> option. But this
would just print the trailing log lines as they come in, and it would I<not>
print the legend, which is at the start of the file. This legend is needed to
keep our column labels, so that we can process the log with other tools. To do
that, we can use this tool instead of a plain C<sort -f>. This tool simply
prints out the log until it sees a legend (inclusively), and then runs the
C<sort -f> as usual. So we can do

 $ asciilog-sort tst.asciilog | asciilog-filter x y z | feedgnuplot --stream --3d --lines

This usage will start printing out all the data written to the log file as it
comes in. Thus all data that is I<already> in the log is ignored. If this is
undesireable, we can use the fact that this tool is a very thin wrapper around
the C<sort> utility, and all aruments are passed to C<sort> verbatim. It is
possible to ask C<sort> to print out all lines except the first (so that we
don't print the legend twice, assuming the legend is on the first line) and
I<then> to output new data:

 $ asciilog-sort -n+2 tst.asciilog | ....

=head1 REQUIRED ARGUMENTS

We need the log file as the only argument

=head1 REPOSITORY

https://github.com/dkogan/asciilog/

=head1 AUTHOR

Dima Kogan C<< <dima@secretsauce.net> >>

=head1 LICENSE AND COPYRIGHT

Copyright 2016 California Institute of Technology.
Copyright 2017 Dima Kogan

This library is free software; you can redistribute it and/or modify it under
the terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at your option) any
later version.

=cut
